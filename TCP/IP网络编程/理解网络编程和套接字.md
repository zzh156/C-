# 构建接电话套接字（将TCP比喻为电话机，这是服务器端）
1.创建套接字
```c
#include<sys/socket.h>
int socket(int domain,int type,int protocol);
//成功时返回文件描述符，失败返回-1  domain区域  protocol 协议
```
2.给创建好的套接字分配地址信息(IP地址和端口号)
```c
#include<sys/socket.h>
int bind(int sockfd,struct sockaddr* myaddr,socklen_t  addrlen);
//成功时返回0，失败是返回-1 sockfd是通过bind函数给socket绑定的名字
//socklen_t 与int 类似
```
3.调用listen函数,把套接字转化为可接收连接的状态
```c
#include<sys/socket.h>
int listen(int sockfd,int backlog);
//成功时返回0 失败时返回-1
//backlog指定了一个监听状态的套接字能够接受的未处理连接请求的最大数量。
```
4.如果有人为了完成数据传输而请求连接，用accept函数进行受理
```c
#include<sys/socket.h>
int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen);
//成功时返回文件描述符，失败时返回-1
``` 
#构建打电话套接字(客户端套接字)
1.调用socket函数创建套接字
略
2.调用connect函数向服务器端发送连接请求
```c
#include<sys/socket.h>
int connect (int sockfd ,struct sockaddr * serv_addr,socklen_t addrlen);   
```
#在linux平台下运行
GCC(linux 下的 c语言编译器)
```cpp
gcc hello_server.c -o hserver
//编译hello_server文件并生成可执行文件hserver

./hserver
//运行当前目录下的hserver文件

//运行服务器端
gcc hello_server.c -o hserver //编译hello_server.c文件并生成可执行文件hserver
./hserver 9190 //运行当前目录下的hserver文件

//运行客户端
gcc hello_client.c -o hclient
./hclient 127.0.0.1 9190
```
#Linux 中的文件操作
linux中对socket的操作与文件的操作没有区别
而windows区分对socket的操作和对文件的操作

底层的含义:与标准无关的操作系统独立提供的

```c
//文件描述符                               对象
 0                                       //标准输入 Standard input
 1                                       //标准输出 standard output
 2                                       //标准错误 Standard Error
//这三种对象特殊，不经过特殊的创建过程也有，程序开始运行后也会被自动分配文件描述符。
//文件描述符  在windows中称为句柄，linux平台称为描述符
```
##打开文件
```c
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
int open(const char *path, int flags);
//成功时返回文件描述符，失败则返回-1
```
##关闭文件
```c
#include<unistd.h>
int close(int fd)
//成功时返回0，失败时返回-1  fd文件描述符参数
```
##将数据写入文件
```c
#include<unistd.h>
ssize_t read(int fd, const char *buf,size_t nbytes);
//fd 数据传输对象的文件描述符
//buf 保存要传输数据的缓冲地址值
//nbytes 要传输数据的字节数
```
##头文件分析
```c
1.stdlib.h 是 C 语言标准库中的一个头文件，主要包含了关于内存管理、进程控制、字符串转换、随机数生成和算法排序等方面的函数。

具体包括以下函数：

内存管理函数：malloc()、calloc()、realloc()、free() 等用于动态内存分配和释放的函数。

进程控制函数：exit()、abort()、system() 等用于进程控制的函数。

字符串转换函数：atoi()、atol()、atof()、itoa() 等用于字符串和数值之间的转换的函数。

随机数生成函数：rand()、srand() 等用于生成随机数的函数。

排序算法函数：qsort() 等用于排序的函数。

此外，该头文件中还包含一些其他的函数，如内存操作函数：memset()、memcpy()、memmove() 等，以及一些数学运算相关的函数：abs()、labs()、div()、ldiv() 等。

这些函数通常是使用起来比较方便的工具，经常在C语言编程中使用。开发人员可以直接使用这些函数而不需要自己写相应的代码，从而提高程序的开发效率和效果



2.fcntl.h 是 C 语言标准库中的一个头文件，主要包含了关于文件描述符操作和文件控制的函数和常量。

具体包括以下内容：

文件描述符操作函数：open()、close()、read()、write() 等用于文件的打开、关闭、读写操作的函数。

文件控制函数：fcntl()、ioctl() 等用于对文件进行控制和设置的函数。

文件打开模式常量：O_RDONLY、O_WRONLY、O_RDWR 等表示文件打开模式的常量。

文件访问权限常量：S_IRUSR、S_IWUSR、S_IXUSR 等表示文件访问权限的常量。

文件锁类型常量：F_RDLCK、F_WRLCK、F_UNLCK 等表示文件锁的类型和状态的常量。

此外，该头文件中还包含一些其他的常量和函数，如文件状态标志常量：O_APPEND、O_CREAT、O_TRUNC 等，以及其他一些文件描述符的操作函数和控制函数。

这些函数和常量通常是用于 C 语言中对于文件操作和控制的操作，例如打开、关闭、读写文件、文件锁定等操作。一般来说，这些操作在 Linux/Unix 环境下使用得比较多

3.unistd.h 是 C 语言标准库中的一个头文件，在 Unix 系统和 Linux 系统中广泛使用。该头文件中包含了许多与 UNIX 操作系统相关的函数、常量和类型的定义。

具体包括以下内容：

进程控制函数：fork()、execve()、wait() 等用于进程控制的函数。

文件操作函数：read()、write()、close()、dup() 等用于文件操作的函数。

目录操作函数：chdir()、getcwd()、opendir()、readdir() 等用于目录操作的函数。

系统调用函数：sleep()、pause()、getpid()、getppid() 等用于系统调用的函数。

系统资源限制函数：getrlimit()、setrlimit() 等用于系统资源限制的函数。

此外，该头文件中还包含其他一些函数、常量和类型的定义，例如 STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO 等标准文件描述符常量，以及 ssize_t、pid_t、uid_t、gid_t 等类型的定义。

这些函数和常量通常是用于在 Unix 和 Linux 系统下进行系统编程的操作，例如进程控制、文件系统操作、系统资源管理等。因此，在进行 Linux 或者 UNIX 系统编程的时候，经常需要使用 unistd.h 头文件提供的函数和常量来实现相应的操作 
```
##读取文件中的数据
```c
#include<unistd.h>
ssize_t read(int fd,void*buf,size_t nbytes)

```






# 0.使用linux gcc 编译 c语言
```cpp
1.//创建代码文件：在终端中使用文本编辑器创建编写 C 或 C++ 代码文件。例如，使用 nano 编辑器创建一个 “hello.c” 文件：
nano hello.c
2.//编写代码：在文本编辑器中编写程序代码。例如，编写一个简单的 “Hello World” 程序
#include <stdio.h>
int main()
{
   printf("Hello World!\n");
   return 0;
}
3.//ctrl+o 保存代码文件，重新取名为helloworld.c (这也是后面编译要用的名字) 点击yes
//ctrl+x 退出nano编辑器
4.//编译代码：在终端中使用 GCC 编译代码文件。GCC 编译器的命令格式如下：
gcc helloworld.c -o helloworld
5.//运行程序：使用以下命令运行当前目录生成的可执行文件：
./helloworld
 
```

