# 理解TCP和UDP
TCP又称基于流的套接字，TCP是传输控制协议的简写，意为对数据传输过程的控制
# TCP/IP协议栈
                      应用层
   TCP                        UDP
            IP
            链路层
通过TCP套接字收发数据需要经过四层
                    应用层
            TCP                        
            IP
            链路层
通过UDP套接字收发数据四层
                    应用层                    
                     UDP
            IP
            链路层
各层可能通过操作系统等软件实现，也可能通过类似NIC的硬件设备实现
# 链路层
负责物理链接  分为 LAN WAN MAN等网络标准
# IP层
解决传输数据需要经过哪条路径的问题
IP本身是面向消息的，不可靠的协议，每次传输数据会帮我们选择路径，但并不一致，如果路径错误则选其他路径，但如果发生数据丢失或错误，无法解决
IP协议无法应对数据错误
# TCP/UDP 层
又称传输层
IP层的传输顺序和传输本身都是不可靠的，TCP的作用是数据交换过程中确认对方已收到数据，并重传丢失的数据，那么即使IP层不保证数据传输，这类通信也是可靠的
# 应用层
根据程序特点决定服务器端和客户端之间的数据传输规则，这就是应用层协议，网络编程大部分内容就是设计并实现应用层协议

# 实现基于TCP的服务器端/客户端
##TCP服务器端的默认函数调用顺序
```c
     socket()//创建套接字
     bind()//分配套接字地址
     listen()//等待连接请求状态
     accept()//允许连接
     read()/write()//数据交换
    close()//断开连接
```
##进入等待连接请求状态
```c
#include<sys/socket.h>
int listen(int sock,int backlog);
//成功返回0  失败返回-1
//sock 传递的描述符套接字参数将成为服务器端套接字（监听套接字）
//backlog 最多使几个连接请求进入队列

```
等待连接请求状态：客户端请求连接时，受理连接前，一直使请求处于等待状态。
listen函数第二个参数值与服务器的特性有关，像频繁接受请求的web服务器端至少应为15，另外，连接请求等待队列的大小始终根据实验结果而定

# 受理客户端连接请求
服务器端套接字是做门卫的，要一个新的套接字，由accept自动创建
```c
include<sys.socket.h>
int accept(int sock,struct sockaddr *addr,int flags);
//成功时返回创建的套接字文件描述符，失败时返回-1
//sock 服务器套接字的文件描述符
//addr 保存发起请求的客户端地址信息的变量地址值
//addrlen 存有第二个结构体长度的变量地址
```
# TCP客户端的默认函数调用顺序
    socket() 创建套接字
    connect() 请求连接
    read()/write() 交换数据
    close 断开连接
```c
//发起连接请求
#include<sys/socket.h>
int connect(int sock,struct sockaddr* servaddr,socklen_t addrlen);
//sock 客户端套接字文件描述符
//servaddr 保存目标服务器端地址信息的变量地址值
//addrlen 以字节为单位传递已传递给第二个参数的地址变量长度

```
客户端调用connect函数后，下面2种情况才会返回
1.服务器端接收连接请求
2.发生断网等异常情况而中断连接请求
所谓的接受连接并不意味者服务器端调用accept函数，其实是服务器端把连接请求信息记录到等待队列，因此connect函数返回后并不立即进行数据交换

客户端套接字的地址在哪？
何时 在调用connect函数时分配
何地  操作系统内核
如何  IP用主机ip，端口随机
无需使用bind函数分配

# 基于TCP IP 的服务器端/客户端函数调用关系
客户端只能等到服务器端调用listen()函数之后才能调用connect()函数，但可能率先调用accept()函数，此时accept函数进入阻塞状态，知道客户端调用connect()函数为止。
# 实现迭代服务器端/客户端
回声服务器端/客户端 ：服务器端将客户端传输的字符串原封不动的传回客户端，就像回声一样。
## 实现迭代服务器端
插入循环语句反复调用accept函数
socket()
bind()
listen()
accept()(循环)
read()/write()(循环)
close(client)(循环)
close(server)
