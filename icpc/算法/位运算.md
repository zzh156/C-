# 位运算
给定一个长度为 n
 的数列，请你求出数列中每个数的二进制表示中 1
 的个数。

输入格式
第一行包含整数 n
。

第二行包含 n
 个整数，表示整个数列。

输出格式
共一行，包含 n
 个整数，其中的第 i
 个数表示数列中的第 i
 个数的二进制表示中 1
 的个数。

数据范围
1≤n≤100000
,
0≤数列中元素的值≤109
输入样例：
5
1 2 3 4 5
输出样例：
1 1 2 1 2


## 算法1. lowbit
**lowbit算法截取一个整数的二进制最后一个1后面的所有数，每次截取一个1，截取的次数就是lowbit的次数。lowbit是通过该数与负数形式的与运算得到的。
比如10001000的负数以补码存储(反码+1)，是01111000，与运算得到1000，原数减去补码得到10000000，再进行一次相同运算得到00000000，0时跳出while循环，并记下lowbit运算次数是2**


```cpp
#include<iostream>
using namespace std;
void lowbit(int n)
{
    int result=0;
    while(n)
    {
    int b=n&(-n);
    n=n-b;
    result++;
    }
    cout<<result<<" ";
    
}
int main()
{
    int num;
    cin>>num;
    while(num--)
    {
        int n;
        cin>>n;
        lowbit(n);
    }
}
```
算法2.
## 暴力枚举
**把给的数的二进制形式与1作与运算，得到的就是最后一位，把最后一个叠加再累加器（初始值0）上，然后把原数向右移一位(犯了个错哈哈，右移位本身不会改变数的值，而必须要把右移位的数赋值给初值才能改变值。)**
```cpp
#include<iostream>
using namespace std;
int main()
{
    int n;
    cin>>n;
    while(n--)
    {
        int b;
        cin>>b;
        int k=0;
        while(b)
        {
            k+=b&1;
            b=b>>1;
        }
        cout<<k<<" ";
    }
}
```
注意: b=b>>1; 而不是b>>1;b>>1不会改变b的值(哭);