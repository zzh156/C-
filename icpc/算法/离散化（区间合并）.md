# 离散化
**值的范围大，但是个数少，可以把值作为下标来用数组存储，但是比如(值的范围是1e9，个数是1e5)，总不能开个1e9那么大的数组吧，所以我们要通过某些规则来将数映射到另一个位置，这个过程就叫离散化，一般有两步，第一步去重，先把原数组里面重复的值去掉。第二步，建立映射，算出a[n]离散化后的值。如果要求原区间上某一段的值可以把那一段x 映射到新的数组的某一个区间求值**
# 题目
区间和
   题目
   提交记录
   讨论
   题解
   视频讲解

假定有一个无限长的数轴，数轴上每个坐标上的数都是 0
。

现在，我们首先进行 n
 次操作，每次操作将某一位置 x
 上的数加 c
。

接下来，进行 m
 次询问，每个询问包含两个整数 l
 和 r
，你需要求出在区间 [l,r]
 之间的所有数的和。

输入格式
第一行包含两个整数 n
 和 m
。

接下来 n
 行，每行包含两个整数 x
 和 c
。

再接下来 m
 行，每行包含两个整数 l
 和 r
。

输出格式
共 m
 行，每行输出一个询问中所求的区间内数字和。

数据范围
−109≤x≤109
,
1≤n,m≤105
,
−109≤l≤r≤109
,
−10000≤c≤10000
输入样例：
3 3
1 2
3 6
7 5
1 3
4 6
7 8
输出样例：
8
0
5
难度：简单
时/空限制：2s / 64MB
总通过数：69479
总尝试数：119621
来源：模板题
算法标签

**自己做了一个方法如下，答案还没遇到错的，但是超时了，（qwq真的好恶心啊，上百个数据就是要卡你的算法）**
```cpp
#include<iostream>
#include<vector>
#include<algorithm>
#include<cstdio>
using namespace std;
typedef pair<int,int> p;
int main()
{
   int n,m;
   scanf("%d%d",&n,&m);
   vector<p>v;
   while(n--)
   {
       int x,c;
       scanf("%d%d",&x,&c);
       v.push_back({x,c});
   }
   sort(v.begin(),v.end());
   while(m--)
   {
       int begin,end;
      scanf("%d%d",&begin,&end);
       int begin1,end1;
       for(int i=0;i<v.size();i++)
       {
           if(begin<=v[i].first)
           {
           begin1=i;
           break;
           }
           if(i==v.size()-1)
           {
               begin1=v.size();
           }
           
       }
       for(int i=0;i<v.size();i++)
       {
           if(end<v[i].first)
           {
            end1=i-1;
            break;
           }
           if(i==v.size()-1)
           {
               end1=i;
           }
       }
       int sum=0;
       for(int i=begin1;i<=end1;i++)
       {
           sum=sum+v[i].second;
       }
      cout<<sum<<endl;
   }
}
```



