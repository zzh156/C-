# 快速排序

给定你一个长度为 n
 的整数数列。

请你使用快速排序对这个数列按照从小到大进行排序。

并将排好序的数列按顺序输出。

输入格式
输入共两行，第一行包含整数 n
。

第二行包含 n
 个整数（所有整数均在 1∼109
 范围内），表示整个数列。

输出格式
输出共一行，包含 n
 个整数，表示排好序的数列。

数据范围
1≤n≤100000
输入样例：
5
3 1 2 4 5
输出样例：
1 2 3 4 5
```cpp
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

void quick_sort(vector<int>& v, int l, int r)
{
    if (l >= r)
    {
        return;
    }

    int j = l - 1, h = r + 1;
    int a = v[(j + h) >> 1];
    while (j < h)
    {
        do j++; while (v[j] < a);
        do h--; while (v[h] > a);
        if (j < h)
            swap(v[j], v[h]);
    }
    quick_sort(v, l, h); quick_sort(v, h + 1, r);

}

int main()
{
    int num;
    cin >> num;
    vector<int>v(num);
    for (int i = 0; i < num; i++)
    {
        cin >> v[i];
    }
    quick_sort(v, 0, num - 1);
    for (int i = 0; i < num; ++i)
    {
        cout << v[i] << " ";
    }
    return 0;
}

```

注意这行
```cpp
quick_sort(v, l, h); quick_sort(v, h + 1, r);
```
以右指针作为递归的分界，而不是左指针，不然会造成遗漏
改了好久(哭);

# 第k个数
**又犯了一个错，每次调用快速排序算法之前，一定要保证快排分隔点mid的值一定，而不是固定索引，因为就算索引固定，在循环中排序一次可能把分隔点的位置的值给排到其他地方去，你再用固定的索引去找的值就不是一开始的分隔值了，会导致标准改变，排序变得没有顺序**

```cpp
#include<iostream>
#include<vector>
using namespace std;
void quick_sort(vector<int>&v,int l,int r)
{
    if(l>=r)
    return;
    
    int g=l-1;int h=r+1;
    int mid=v[(g+h)>>1]; //一种错误写法是int mid=(g+h)>>1
    while(g<h)    //然后通过mid索引来定位标准值 殊不知while排序一旦把
    {            //标准值换位置了，定位到的就不是标准值了。排序全乱了
        do g++;while(v[g]<mid);
        do h--;while(v[h]>mid);
        if(g<h) 
        swap(v[g],v[h]);
        
    }
    quick_sort(v,l,h);
    quick_sort(v,h+1,r);
    
}

int main()
{
    int n,point;
    cin>>n>>point;
    vector<int>v(n);
    for(int i=0;i<n;i++)
    {
        cin>>v[i];
    }
    quick_sort(v,0,n-1);
    
    cout<<v[point-1];
    
}
```