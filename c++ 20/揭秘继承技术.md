# 拓展类
```cpp
class Base
{
public:
    void someMethod(){};
protected:
    int m_protectedInt{0};
private:
    int m_privateInt{0};    
};
class Derived: public Base
{
public:
    void someOtherMethod(){};    
};

```
## 客户对继承的看法
使用派生类的代码不需要知道是派生链条中哪个类定义了这个方法。
调用父类的方法直接用，不需要写什么。

继承的关系是单向的，父类不知道子类

指向某个对象的指针或引用可以指向声明类的对象，也可以指向其任意派生类的对象

受保护的成员只可以在 自己类 子类 友元函数被访问 ，外部不可见 （main不可见）

在C++中父类的私有数据成员可以被子类继承，但是不能被子类直接访问（包括读取和写入），子类可以通过调用父类的公有或保护成员函数来读取或写入子类继承的父类的私有数据成员。

**将派生类的地址赋给基类类型的指针，该指针依然只能访问派生类的基类成员（不能直接访问继承的private成员），因为指针变量的类型只是指针的类型，通常不会改变所指变量的类型。**

访问基类的数据成员及方法与访问派生类继承自基类的数据成员或方法并无不同之处（不重写）

C++中类的接口是指所有可以从类的外部访问的类的公有成员函数（包括普通函数和构造和析构函数）和类的公有数据成员

**C++中把数据成员默认设置为private的原因是，这会提供最高级别的封装，这意味者可以改变数据的表示方式，而保持public或protected的接口不变**这句话的理解：

**如果把数据成员设置为public，类外的代码直接访问，如果数据成员被修改，类外代码将错误，但是如果把数据成员变成私有，类外只可通过接口访问，则随便改数据成员，外面也不会错，这给了设计者最大的自由。**

并且可以在public和protected的setter中方便的添加对输入数据的检查

禁用继承：在基类后表明final
```cpp
class Foo final{};//不能将final类类型用作基类
```
# 重写方法
只有基类中声明为virtual的方法才能被派生类正确的重写，关键词virtual出现在方法声明的开头
```cpp
virtual void someMethod();//也可以直接给出定义
```
派生类的重新声明，添加override,删去virtual
```cpp
void someMethod() override //也可直接给出定义

```
**在重写方法的前面添加virtual是正确但多余的**
```cpp
virtual void someMethod() override;
```
因为一旦将方法或析构函数标记为virtual，它们在所有的派生类中一直是virtual，即使从派生类中删除了virtual关键字也是如此

# 客户对重写方法的看法
将派生类的对象赋值给基类的引用，该引用只能调用派生类中基类的方法，如果基类的方法在派生类中重写，那么调用的是重写后的版本。
```cpp
Derived myDerived;
Base& ref{myDerived};
ref.someMethod(); //Calls Derived's version of someMethod;
```
将派生类赋值或转化给基类，将丢失派生类所有的特征信息
通过类型转换将派生类对象转化为基类对象时，就会丢失其独有特征，重写方法和派生类数据的丢失称为**截断**。

将派生类对象赋值给基类的引用，用基类引用调用的方法如果正确重写了，调用派生类中的重写后的方法，如果没有正确重写，比如基类参数是double 派生类是int，也就是创建了一个新的虚函数，那么如果传入一个实参double，那么调用的将是基类的重写前的方法。
 
override可以不写，但最好写上，防止不小心创建了一个新的虚方法而不自知（形式参数重写错误）。
另外，重命名基类的方法，而忘记重命名派生类的重写方法也会发生创建了一个新的虚方法，而不是重写。

# virtual的真相
重写方法不写virtual的后果是，派生类看似重写的方法与被重写的完全无关，实际上是创建了一个新的方法
```cpp
//错误示范
void go(){```}
void go(){`````}
```
**试图重写非虚方法将会“隐藏”基类定义的方法，并且重写的这个方法只能在派生类环境中使用。**
# 如何实现virtual

**比较静态绑定与动态绑定**
静态绑定
编译期确定要调用的函数是哪个，通过函数签名（函数名和形参）和作用域解析规则确定，每次调用时，将函数代码插入调用处，因为在编译期就绑定了，所以无法实现多态性（如果使用静态绑定调用一个虚函数，或派生类的指针或引用的基函数，只能调用基类的函数）。但是速度很快。
 
 







