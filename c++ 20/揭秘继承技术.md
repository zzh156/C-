# 拓展类
```cpp
class Base
{
public:
    void someMethod(){};
protected:
    int m_protectedInt{0};
private:
    int m_privateInt{0};    
};
class Derived: public Base
{
public:
    void someOtherMethod(){};    
};

```
## 客户对继承的看法
使用派生类的代码不需要知道是派生链条中哪个类定义了这个方法。
调用父类的方法直接用，不需要写什么。

继承的关系是单向的，父类不知道子类

指向某个对象的指针或引用可以指向声明类的对象，也可以指向其任意派生类的对象

受保护的成员只可以在 自己类 子类 友元函数被访问 ，外部不可见 （main不可见）

在C++中父类的私有数据成员可以被子类继承，但是不能被子类直接访问（包括读取和写入），子类可以通过调用父类的公有或保护成员函数来读取或写入子类继承的父类的私有数据成员。

**将派生类的地址赋给基类类型的指针，该指针依然只能访问派生类的基类成员（不能直接访问继承的private成员），因为指针变量的类型只是指针的类型，通常不会改变所指变量的类型。**

访问基类的数据成员及方法与访问派生类继承自基类的数据成员或方法并无不同之处（不重写）

C++中类的接口是指所有可以从类的外部访问的类的公有成员函数（包括普通函数和构造和析构函数）和类的公有数据成员

**C++中把数据成员默认设置为private的原因是，这会提供最高级别的封装，这意味者可以改变数据的表示方式，而保持public或protected的接口不变**这句话的理解：

**如果把数据成员设置为public，类外的代码直接访问，如果数据成员被修改，类外代码将错误，但是如果把数据成员变成私有，类外只可通过接口访问，则随便改数据成员，外面也不会错，这给了设计者最大的自由。**

并且可以在public和protected的setter中方便的添加对输入数据的检查

禁用继承：在基类后表明final
```cpp
class Foo final{};//不能将final类类型用作基类
```
# 重写方法
只有基类中声明为virtual的方法才能被派生类正确的重写，关键词virtual出现在方法声明的开头
```cpp
virtual void someMethod();//也可以直接给出定义
```
派生类的重新声明，添加override,删去virtual
```cpp
void someMethod() override //也可直接给出定义

```
**在重写方法的前面添加virtual是正确但多余的**
```cpp
virtual void someMethod() override;
```
因为一旦将方法或析构函数标记为virtual，它们在所有的派生类中一直是virtual，即使从派生类中删除了virtual关键字也是如此

# 客户对重写方法的看法
将派生类的对象赋值给基类的引用，该引用只能调用派生类中基类的方法，如果基类的方法在派生类中重写，那么调用的是重写后的版本。
```cpp
Derived myDerived;
Base& ref{myDerived};
ref.someMethod(); //Calls Derived's version of someMethod;
```
将派生类赋值或转化给基类，将丢失派生类所有的特征信息
通过类型转换将派生类对象转化为基类对象时，就会丢失其独有特征，重写方法和派生类数据的丢失称为**截断**。

将派生类对象赋值给基类的引用，用基类引用调用的方法如果正确重写了，调用派生类中的重写后的方法，如果没有正确重写，比如基类参数是double 派生类是int，也就是创建了一个新的虚函数，那么如果传入一个实参double，那么调用的将是基类的重写前的方法。
 
override可以不写，但最好写上，防止不小心创建了一个新的虚方法而不自知（形式参数重写错误）。
另外，重命名基类的方法，而忘记重命名派生类的重写方法也会发生创建了一个新的虚方法，而不是重写。

# virtual的真相
重写方法不写virtual的后果是，派生类看似重写的方法与被重写的完全无关，实际上是创建了一个新的方法
```cpp
//错误示范
void go(){```}
void go(){`````}
```
**试图重写非虚方法将会“隐藏”基类定义的方法，并且重写的这个方法只能在派生类环境中使用。**
# 如何实现virtual
每个至少含有一个虚方法的类都有一张虚表，这个类的每个对象都包含指向虚表的指针，这个虚表包含指向虚方法实现的指针。对象调用方法，指针进入虚表，然后根据实际的对象类型在运行时执行正确版本的方法.
**比较静态绑定与动态绑定**
静态绑定
编译期确定要调用的函数是哪个，通过函数签名（函数名和形参）和作用域解析规则确定，每次调用时，将函数代码插入调用处，因为在编译期就绑定了，所以无法实现多态性（如果使用静态绑定调用一个虚函数，或派生类的指针或引用的基函数，只能调用基类的函数）。但是速度很快。
动态绑定
 每个至少含有一个虚方法的类都有一张虚表，这个类的每个对象都包含指向虚表的指针，这个虚表包含指向虚方法实现的指针。对象调用方法，指针进入虚表，然后根据实际的对象类型在运行时执行正确版本的方法.
虚表中不包含指向非虚方法实现的指针

# 使用virtual的理由
一些语言，比如Java所有的方法默认virtual，可以被正确的重写。C++不是，c++创建virtual关键字的原因与虚表的开销有关，及对指向要执行的适当代码的指针解除引用，这带来时间上的开销，此外，每个对象要保存虚指针，也将带来空间上的占用。
# 虚析构函数的需求
析构函数都应该被标记virtual，否则容易销毁对象不释放内存。唯一允许不把析构函数标记为virtual的是，当类被标记为final
 ```cpp
 #include<iostream>

class Base
{
public:
	Base() {};
	~Base() {
		std::cout << "Base deallocated" << std::endl;
	}


};
class Derived :public Base
{
public:
	Derived()
	{
		 m_string = new char[30];
		std::cout << "m_string allocated" << std::endl;
	}
	~Derived()
	{
		delete[] m_string;
		std::cout << "m_string deallocated" << std::endl;
	}
private:
	char* m_string;

};
int main()
{
	Base* ptr{ new Derived() };
	delete ptr;//未定义行为，编译器会随意做事
}
 ```
运行结果:
```cpp
m_string allocated
Base deallocated  //只析构了基类的对象，没有析构派生类的对象 
```
如果析构函数不做事，可显式的把它设置为=default
```cpp
class Base
public:
virtual ~Base()=default;
```
从C++ 11开始 如果类中有用户声明的析构函数，那么将不再生成拷贝构造函数，拷贝赋值运算符，移动构造函数，移动赋值运算符。可将他们显式设置为默认（=default）

最好将除了构造函数之外的所有方法声明为virtual（包括析构），构造函数不可以声明为virtual有两个原因。1.调用构造函数时，对象还没构造好，无法为对象分配一个指向虚表的指针。2.构造函数要初始化所有的成员变量和状态，也与派生类有关，在构造函数使用多态是不安全的。
# 禁用重写
将方法标记为final，无法在派生类重写这个方法。
# 使用继承重用代码
在C++中，export关键字已经从语言标准中删除，因此export class WeatherPrediction这样的语句是不合法的。

在早期版本的C++中，export关键字可以用于标识一个类或函数在可重用的代码库中的可导出状态。例如，export class WeatherPrediction表示WeatherPrediction类可以被导出为一个独立的代码库，其他程序可以在链接库的上下文中使用这个类。这种用法旨在支持可移植和可重用的代码库，但这种应用在实践中很少使用，并且并没有被广泛接受。

在现代C++中，可以使用头文件和命名空间等机制来组织代码和模块，通过模板和模板类等代码机制来支持泛型编程，使用动态链接库和静态库等链接机制来支持代码库的共享和复用。但是，这些机制都没有必要使用export关键字来实现。

因此，export class WeatherPrediction在现代C++中无效，可以忽略export关键字。

**如果基类的默认构造函数不存在，或者存在默认，但希望调用其他版本的构造函数，可在构造函数初始化器中像初始化数据成员那样链接构造函数**
```cpp
#include<iostream>
class Base
{
public:
	Base(int i)
	{
		std::cout << "constructor of Base called";
	}
};
class Derived : public Base
{
public:
	Derived():Base{4}
	{

	}
};
int main()
{
	Derived d;
}
```
不可以在派生类构造函数向基类构造函数传参时，传入派生类独有的数据成员，因为构造顺序是先构造基类，派生类还没构造，派生类的数据成员还没有，所以无法用派生类数据成员初始化基类的数据成员
```cpp
#include<iostream>
class Base
{
public:
	int Base_int;
	Base(int i)
	{
		Base_int = i;
		std::cout << Base_int;
	}
};
class Derived : public Base
{
public:
	int Derived_int = 6;
	Derived():Base{Derived_int}
	{

	}
};
int main()
{
	Derived d;
}

//结果：-858993460
```
基类的虚方法在派生类中重写，如果基类构造函数 调用该方法，调用的是基类重写之前的版本。
# 父类的析构函数

```cpp
class Something
{
public:
	Something() {
		std::cout << "2";
	}
	virtual ~Something() { std::cout << "2"; }
};
class Base {
public:
	Base()
	{
		std::cout << "1" << std::endl;

	}
	virtual ~Base()
	{
		std::cout << "1";
	}
};
class Derived :public Base
{
public:
	Derived() {
		std::cout << "3";
	}
	virtual~Derived() {
		std::cout << "3";
	}
private:
	Something m_dataMember;
};
```
如果delete 一个指向派生类对象的基类指针，那么如果析构函数都不声明virtual的话，只会调用该基类对象的析构函数。

与构造函数一样，在析构函数中调用虚方法时，虚方法的行为有所不同，如果派生类重写了基类的虚方法，在基类的析构函数调用的是基类的重写前版本。

# 截断的后果
将派生类对象赋值给基类对象会导致截断，虽然和正确方法（将派生类对象赋值给基类的指针或引用一样无法访问派生类特有的成员）但是如果虚函数重写了，指针或引用可以访问重写后的，而对象赋值只能访问重写前的
# static_cast与dynamic cast的区别
dynamic_cast只能用于有虚表的对象，即至少有一个虚成员的对象。
如果针对某个指针的dynamic_cast失败，那么它的值就是nullptr，而不是指向某个无意义的数据
针对引用的dynamic_cast失败，抛出std::bad_cast异常

static_cast用法

1.将一种内置类型转换为另一种内置类型
```cpp
int i = 10;
double d = static_cast<double>(i);  // 将int型变量i转换为double型变量d
```
2.将指针或引用类型转换为另一种指针或引用类型
```cpp
Base* b = new Derived();  // 在堆中创建一个派生类对象，将其指针赋给基类指针b
Derived* d = static_cast<Derived*>(b);  // 将基类指针b转换为派生类指针d
```

# 设计多态性的电子表格单元格
  string_view类型用于接受常量字符串








