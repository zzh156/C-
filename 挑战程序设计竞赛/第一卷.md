# DFS和BFS
## BFS
从离初始点近的开始向外一圈圈的搜索
复杂度是O
利用队列，从队列前端取出状态，把该状态可以转移到的状态中尚未访问的部分加入队列
**迷宫的最短路径**
给定一个n*m的迷宫，由通道和墙壁组成，每一步可以向邻接的上下左右的通道移动，求起点到终点的最小步数（假定从起点一定可以移动到终点）

求解的问题：最短路径，最少操作 

构建pair或编码int来表示状态，状态更复杂时，用类
要求最短距离，不如用一个d[N][M]把最短距离保存下来，用从充分大的INF来初始化它，标记。

INF也可参与普通运算，INF值过大带来溢出的危险

要向四个方向移动，所以用dx[4]和dy[4]两个数组来表示四个方向向量，用循环实现四方向遍历

```cpp
const int INF =100000000;
//用pair表示状态时，使用typedef会更方便
typedef pair<int ,int>P;

char maze[MAX_N][MAX_M+1];//表示迷宫的字符串的数组

int N,M;

int sx,sy;//起点终点

int gx,gy;

int d[MAX_N][MAX_M];//到各个位置的最短距离的数组

int dx[4]={1,0,-1,0};

int dy[4]={0,1,0,-1};

//求从（sx，sy）到（gx，gy）的最短距离
//如果无法达到，则是INF

int bfs()
{
    queue<P>que;
    //把所有位置都初始化为INF
    for(int i =0;i<N；i++)
    for(int j=0;j<M;j++>) d[i][j]=INF;
    //将起点加入队列，并把这一地点的距离设置为0
    que.push(P(sx,sy));
    
    d[sx,sy]=0;
    //不断循环，直到队列长度为0;
    while(que.size())
    {
        //从队列的最前端取出元素
        P p =que.front(); que.pop();
        //如果取出的状态已经是终点，则结束搜索
        if(p.first==gx&& p.second==gy)
        break;
        
        for(int i=0;i<4;i++)
        {
        //移动过后的位置记为(nx,ny)
        int nx=p.first+dx[i],ny=p.second+dy[i];
        //判断是否可以移动，以及是否访问过(d[nx][ny]!=INF即为已经访问过)
        if(0<=nx&&nx<N&&0<=ny&&ny<M&&maze[nx][ny]!='#'&&d[nx][ny]==INF)
        //可以移动的话，则加入队列，并且该位置的距离确定为到p的距离加1
        que.push(P(nx,ny));
        d[nx][ny]=d[p.first][p.second]+1;        


        }
    
    }
    return d[gx][gy];
}

void solve()
{
    int res =bfs();
    printf("%d\n",res);
}



```