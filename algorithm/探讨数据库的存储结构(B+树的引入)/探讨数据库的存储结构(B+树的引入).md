# 从磁盘查找数据，该使用什么数据结构？(探讨)

![image-20230604204340993](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230604204340993.png)



cpu的速度远大于磁盘io的速度，所以cpu不能直接和磁盘交互，中间必须加一块内存。在这个过程中如果交互速率低，最可能的是内存与磁盘的io引起的。分析下影响io有哪些因素呢，读写数据越大速度越慢，所以在这里改进就是要减小每次交互的数据量，前提是满足你的需求。比如以前写的 select * from table 把所有数据加载到内存显然是不行的，只需要ab字段就写，select a,b from table 数据变小，io效率更高。第二个是读写次数变多io效率变低，假如以线性的数组存储数据，最坏得交互n次。但假如我们用二分来查找，他的时间复杂度就是log n 远小于n。改变了一个查找算法，读写次数越来越少，速度越来越快。

第二个是索引，索引就是为了更快的查询数据，其实这种就是键值对的形式，其实很多数据库的索引就是键值对的形式.

![image-20230604205508945](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230604205508945.png)

如果现在让你设计一个文件系统的索引，你该如何设计？

刚才我们说了，文件系统的索引基本都是基于k-v的键值对的。那我们用什么数据结构来设计？我们选线性的方式。

![image-20230604205817622](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230604205817622.png)

乍一看，好像挺快的。哈希函数(H(key)=key%13)计算一个下标就储存到对应的位置。但是存在一个问题，无论你哈希函数设计得再好，都可能存在哈希冲突。

而大量数据就重叠在一起了，产生了大量的线性查询。（我记得是哈希冲突的链表解决法），又退回算法复杂度是n的这样一个级别了，效率会很低。

虽然这个方法等值查找速度很快（查找某一个特定的数），但是如果范围查找，比如现在我要查找1-10的数据，又只能挨个遍历了，又退会算法复杂度是n的级别了。

哈希表不行，那么树表行不行？

首先我们用二叉树，二叉树行不行？

二叉树做索引还是慢，因为他本来是没有序的，还是要一个一个去遍历，算法时间复杂度可能就是n，所以做文件系统还是不合适的。

![image-20230604210740545](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230604210740545.png)

那么我们让你这个树有序行不行？考虑二叉排序树BST,他有一个特点就是，左子树不为空的情况下，左子树上的结点值都小于根节点，右子树上都值都大于根节点。![image-20230604210847230](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230604210847230.png)

二叉排序树的致命缺点是，对于某些数据它会退化成一条链表，又变回了O（n）的时间复杂度。

![image-20230604211128226](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230604211128226.png)

再改进，我不让你变成一条链表，如果你变成这样，我就把你旋转。

这就是平衡二叉树（AVL树）

![image-20230604211335362](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230604211335362.png)

插入数据时要保持树的平衡，怎么保持？

有一个平衡因子，左子树和右子树的高度差不能大于1.

平衡二叉树也是一颗有序的树，并且平衡二叉树不会变成链表状的形态，保证了高的查询效率，那么他有没有问题呢？

有的

插入数据时要改变树的形态也是要算法开销的。

它其实在用插入的成本弥补查询的效率

如果你遇到插入特别少，查找特别多的，这种就特别6b，很快

但是一旦出现插入比查询多的情况下，AVL就不合适了，你要花费大量的时间去做LL旋转或者R旋转去保持平衡。



再给它过度一下到红黑树

他与AVL树最大的不同(AVL树有一个平衡因子，左子树和右子树的高度差不能大于1.)

而红黑树改成了 最长子树不超过最短子树的2倍即可

为什么不超过2倍？因为不让他做大量的旋转。

![image-20230604212309302](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230604212309302.png)

红黑树有很多特性

1.根节点是黑色。

2.每个红色结点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）

3.从任一节点到每个叶子结点的所有路径都包含数目相同的黑色结点

红黑树他仍然是一颗排序树，左子树的值小于根节点，右子树的值大于根节点。红黑树插入的时候不需要那么多旋转，

保证了查找效率的同时，插入效率也是很高的，不用做那么多旋转。

红黑树依然不可以做文件的索引，因为存在一个问题，数据量非常大的时候，树的深度会变得很多，树的深度变多，查找次数就会变多，io的次数会变多，影响效率

所以 红黑树依然不可以作文件系统的索引

那么 有没有一种办法，随着树的插入，树的深度不变深，就不存在这种情况了。

为什么数据的插入会使树的深度变深？因为上面所有的树都是基于二叉树的.

同样数据保持有序，把二叉树变成m叉树就解决了这个问题

B树就是一个有序的多路查询树

**我们成功引入了B树的概念！**



满足下列要求的m叉树就是B树

1.树中的每个结点至多有m个孩子结点（即至多有m-1个关键字）

括号外的很好理解

关键是这个，至多有m-1个关键字

每个结点的结构：

因为他上面也会有隔开的结构

![image-20230605080555442](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605080555442.png)

第一个位置我用n来表示到底有多少个关键字

至多有m-1个关键字，比如m是4，可以有1，2，3个关键字，n就是来记录到底有多少个关键字

然后就是指针与关键字交错排列的形式（指针总是比关键字多1）

既然是m叉树，那也有子树的概念，虽然没有左右子树的概念。那么我怎么找到你的子树呢，还是指针。

顺着P0可以找到第一个子树的地址

接着k1就是我们刚才说的关键字

![image-20230605081535103](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605081535103.png)



指针P0指向的子树上所有的元素 都小于 P0右边的关键字 k0

指针P0指向的子树上的元素是按从小到大的顺序依次排列的。

B树的其他性质：

![image-20230605081758026](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605081758026.png)

# B-Tree 的查找

![image-20230605103923731](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605103923731.png)

其实我们B树是一个多路有序的树

那跟我们之前所有有序的树的查找方法一样的

查找37，先从根节点查找，37比48小，在左边查找，37比25大，在右边查找，哎找到了

![image-20230605104128794](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605104128794.png)

需要注意的是，如果有多个结点，结点也是有序的，可以从左到右查一遍

但是 你要把B-Tree查找搞明白，你得先明白一个操作系统的知识，磁盘预读

![image-20230605104326974](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605104326974.png)

磁盘与内存数据交互的时候，一般情况下有一个最小的逻辑单元，页

页的大小一般是操作系统决定的，4k或8k

在数据交互时，要取datapage的整数倍的空间，比如要2k，就要取4k，要5k，取8k，要9k，取12k

![image-20230605104713908](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605104713908.png)

这个word大小是15.8kb，但是你要占用4*4k= 16kb 的空间（datapage的整数倍）

为什么我要讲这个呢？我要结合操作系统的知识来讲真正的查找过程

![image-20230605105038529](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605105038529.png)

结合操作系统，这是一颗B树

每一个结点，里面有三个内容，key（键值），指针，value（数据）

还有一个n，就是 到底有几个记录，没有关系，可写可不写

B树的每一个结点，都是放在一个磁盘块里面的，也就是一个datapage里面

B树做索引，一般来说规定磁盘块大小是16k

假如我现在要找一个关键字为28的数据

先把磁盘块1加载到内存里面，比较16<28<34,找到p2(第一次io)

顺着p2找到了磁盘块3，把磁盘块3加载到内存中，然后 25<28<31,找到p2(第二次io)

顺着p2找到磁盘块8，把磁盘块8加载到内存中，然后28与关键字比较，找到了28，返回28对应的data

这个才是真正的计算机专业的学生该了解的查找的过程

这是B树作为索引的过程

那么，他有没有什么问题

这个B树能保存多少数据

我总共做了3次io

假设一条记录是1k

指针和关键字先不考虑它的占用空间，因为他占的空间比较小，每一个块上的数据记录就是16条。那这三层下来可以保存 16 ×16×16=4096条记录，

显然数据量大的时候，是不能满足我的需求的

如果我要存10000条数据怎么办？加一层？

但是如果加一层，又退回到io性能的问题了。树的深度越深，查找一个数据的io次数越多，性能就越慢。怎么解决这个问题，我们引出B+ 树。为什么要树的深度变深呢，因为非叶子结点存了大量的数据。那如果我们非叶子结点不存数据了，只存指针和key

![image-20230605111736494](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605111736494.png)

那是不是这个磁盘块就可以存更多的记录了？前两层磁盘块都可以存更多的记录了。那它们乘起来的值是不是越来越大了。最后把所有的数据都挂在叶子结点上。

B-Tree

![image-20230605112240327](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605112240327.png)

B+ Tree

![image-20230605112306319](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605112306319.png)

B+树 数据不占用非叶子结点，只存关键字和指针，这样就可以存储多的多的数据了

B+ 树的形态

![image-20230605112601610](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605112601610.png)

这就是为什么会有B+ 树

B+树的优点

1）B+树的磁盘读写代价更低

其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了；

2）B+树查询效率更加稳定

由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；

3）B+树便于范围查询（最重要的原因，范围查找是数据库的常态）

B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低；

B+树最大的性能问题在于会产生大量的随机IO，主要存在以下两种缺点：

> - 主键不是有序递增的，导致每次插入数据产生大量的数据迁移和空间碎片；
> - 即使主键是有序递增的，大量写请求的分布仍是随机的；  

并且，为什么MySQL数据库索引选择使用B+树？
B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I/O支出。因此，B+树成为了数据库比较优秀的数据结构，MySQL中MyIsAM和InnoDB都是采用的B+树结构。不同的是前者是非聚集索引，后者主键是聚集索引。 

B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。B+树支持range-query(区间查询)非常方便，而B树不支持。

B+ 树通常用于数据库和操作系统的文件系统中。

NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入。



接着我们再来了解一下B*树

![image-20230605151506522](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605151506522.png)



B+树和B*树的区别是啥？

B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；

B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；

## B树的删除过程

![image-20230605170158841](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605170158841.png)

我们先来与二叉树的删除做一个对比，二叉树的删除是这样的，二叉树每个结点中间是值，左右是指向两个子树的指针。通常我们认为删除了这个关键字就是把这个结点删除了。

![image-20230605170429057](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605170429057.png)

我们要删除k2，就是直接把k1指向它的指针指向k3就行了，这个结点就删除了。就是找到要删除结点的下一个结点，来“代他受死”。其实我们B树也是一样的。B树比较特殊，一个结点里可能不止有一个关键字了，可能有k1 k2 k3 等等的关键字。

B树的删除只分为两个大类。先复习一下B树的性质

![image-20230605184437123](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605184437123.png)

1.每个节点最多有m个子节点

2.除根节点和叶子节点，其他每个节点至少有[m/2]（向上取整的意思）个子节点

3.若根节点不是叶子节点，则其至少有2个子节点

4.除根节点外，其他节点都包含n个key，其中[m/2]-1<=n<=m-1

完全可以把删除非叶子节点的关键字转化为删除叶子节点

删除200以后，不满足第4条，那么还有一个从哪来？从下一个，这个节点的下一位找。把230提上来

![image-20230605185105693](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605185105693.png)

将这个之前得引入一个概念，节点的“富有”。

怎么判断节点是不是富有呢，就是删除这个节点之后，节点剩余都key数量仍然大于等于ceil（m/2）-1

假如我这个节点是富有的，要删除这个节点，直接删除就行了。（比如80）没有任何影响.

如果一个节点不富有怎么办？

删除了180之后，节点只有一个关键字了，向他的父节点借过来230，然后他的父节点就变成了穷的节点，再让父节点去向右字节点把240借过来。

![image-20230605185647982](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605185647982.png)

但是如果穷节点的弟弟也没有多余的节点，都借不到怎么办？

![image-20230605185938933](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605185938933.png)

那就降低树的高度

![image-20230605190123771](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605190123771.png)

没有根节点，那就把最上面的两个兄弟节点合并。

但是如果节点的兄弟都很穷，但是父节点很富，可以直接向父亲节点借，然后为了维持B树的特点，把兄弟做一个合并。





