# 贪心算法

**贪心虽然代码很简单，但其实它是最难的算法(没有固定的模板和套路，很难证明)，所以这节课我们以证明为主**

题目一.区间选点

给定 N 个闭区间 [ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。

输出选择的点的最小数量。

位于区间端点上的点也算作区间内。

#### 输入格式

第一行包含整数 N，表示区间数。

接下来 N 行，每行包含两个整数 ai,bi表示一个区间的两个端点。

#### 输出格式

输出一个整数，表示所需的点的最小数量。

#### 数据范围

1≤N≤105,
−109≤ai≤bi≤109

#### 输入样例：

```
3
-1 1
2 4
3 5
```

#### 输出样例：

```
2
```

我们在数轴上选择尽可能少的点，让每个区间至少都有一个点

示意：

![image-20230605215450087](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605215450087.png)

答案是2

贪心区间问题的套路：要么按左端点排序，要么按右端点排序，要么就是双关键字排序

![image-20230605215728491](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605215728491.png)

1.我们把区间的右端点从小到大排序

2.从前往后依次枚举每个区间

在区间上选点的时候尽可能选区间末尾的点（才能最大的可能覆盖下一个区间），如果当前区间已经包含点，那么就pass，否则就选择当前区间的右端点

对于每个区间，我们选择右侧的点（当前看起来最好的点）。贪心的题都有一个特点，每次选择当前的最好情况。他其实是一种比较短视的行为，贪心问题就这样可以走到全局最优解。

贪心只有单峰的情况才能走到最优解（选择局部最高的情况就能走到最高点）

![image-20230605220431766](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605220431766.png)

如果是多峰的情况就不一定走到最大值

![image-20230605220546042](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605220546042.png)

我们要证明选出来的值和最优值相等的话，比方说证明A=B，就从A>=B,A<=B证明出来A=B。

他每个区间都包含一个点。我们选点的方案是一组合法的方案，我们要求一组合法方案的最小值。ANS是可行方案的最小值，而CNT是一组可行方案。

所以ANS<=CNT.

我们来感受一下，所有没有被pass的区间是什么情况。它们之间一定是没有交集的

![image-20230605221409042](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230605221409042.png)

我们找到了CNT个相互间没有交集的区间，每个点只能覆盖一个区间，那么如果我们想要覆盖CNT个区间，所有方案选择的点数一定要>=CNT。

所以证明得到ANS=CNT

```cpp
#include<iostream>
#include<algorithm>
#define N 100001
using namespace std;
struct range
{
	int l; int r;
	bool operator < (const range& a)
	{
		return r < a.r;
	}
};
range Range[N];
int main()
{
	int n;
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		int a, b;
		cin >> a >> b;
		Range[i] = { a,b };
	}
	sort(Range, Range + n);
	long long ed = -1000000000000000;
	int count = 0;
	for (int i = 0; i < n; i++)
	{
		if (Range[i].l > ed)
		{
			count++;
			ed = Range[i].r;
		}
	}
	cout << count<<endl;

}
```

题目2

最大不相交区间数量

给定 N 个闭区间 [ai,bi][��,��]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。

输出可选取区间的最大数量。

#### 输入格式

第一行包含整数 N，表示区间数。

接下来 N 行，每行包含两个整数 ai,bi，表示一个区间的两个端点。

#### 输出格式

输出一个整数，表示可选取区间的最大数量。

#### 数据范围

1≤N≤1051≤≤105,
−109≤ai≤bi≤109

#### 输入样例：

```
3
-1 1
2 4
3 5
```

#### 输出样例：

```
2
```

1.将所有区间按右端点从小到大排序。

2.从左到右依次枚举每个区间。

3.如果当前区间已经包含点，pass。否则选择 当前区间的右端点

代码同上

```cpp
#include<iostream>
#include<algorithm>
#define N 100001
using namespace std;
struct range
{
	int l; int r;
	bool operator < (const range& a)
	{
		return r < a.r;
	}
};
range Range[N];
int main()
{
	int n;
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		int a, b;
		cin >> a >> b;
		Range[i] = { a,b };
	}
	sort(Range, Range + n);
	long long ed = -1000000000000000;
	int count = 0;
	for (int i = 0; i < n; i++)
	{
		if (Range[i].l > ed)
		{
			count++;
			ed = Range[i].r;
		}
	}
	cout << count<<endl;

}
```

题目3.区间分组

给定 N个闭区间 [ai,bi][��,��]，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。

输出最小组数。

#### 输入格式

第一行包含整数 N，表示区间数。

接下来 N 行，每行包含两个整数 ai,bi，表示一个区间的两个端点。

#### 输出格式

输出一个整数，表示最小组数。

#### 数据范围

1≤N≤1051≤�≤105,
−109≤ai≤bi≤109

#### 输入样例：

```
3
-1 1
2 4
3 5
```

#### 输出样例：

```
2
```

1.将所有区间左端点从小到大排序，贪心问题，尤其是区间贪心问题都是按照某一个端点排序，前两个题是按右端点从小到大排序，而这个题反过来需要按照区间左端点从小到大排序，从前往后处理每个区间，判断能否将其放入所有现有的组中，依次判断每个组的左区间最后一个点是否与当前区间最右端点有交集

![image-20230606171909236](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230606171909236.png)

![image-20230606172019165](C:\Users\12779\AppData\Roaming\Typora\typora-user-images\image-20230606172019165.png)

1.如果不存在这样的组，则开新组，然后将其放进去。2.如果存在这样的组，将其放进去，并更新当前组的Max_x

如果有多个组满足条件的话，可以随便挑一个放进去

