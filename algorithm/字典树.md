# 字典树(Trie)

我们在Trie类中定义了每一个结点的属性与行为，每一个结点Trie具有一个指针向量，其中索引0到25分别表示从这个结点出发，到达a到z 结点的情况，如果从这个结点出发到达的c结点存在的话，那么数组的2下标存储了一个指向这个结点的指针

结点的另一个属性是一个boo值叫做 isEnd，判断这个结点是否是一个字符串的结尾，用于后续查找字符串。

结点的一个行为是查找某一个字符串，一开始node是头节点。接着遍历字符串的每一个字符，把每一个字符与'a'字符相减得到在这个结点中查找指针数组的下标，如果查找到对于下标的指针数组上对应指针是nullptr，那么代表这个指针没有这个结点。直接返回空指针 。如果搜索到该字符串的最后一个字符，依然找到了对应children数组上的指针，那么返回指向最后一个结点的指针

结点的构造方法把每一个结点的指针向量的大小设置为26，把初始的isEnd值设置为false

结点还有一个插入字符串的行为，先取得头指针node，然后依次遍历字符串的每一个字符，依次把他减去一个基准'a'，得到了数组的下标，如果这个结点的children数组在这个结点上的下标对应的指针是空指针的话，说明没有对应的下一个结点，我就new一个Trie结点，并且把对应的指针赋值给上一个结点的对应的children数组的对应位置。最后把所有字符插入到结点后，把最后一个结点的isEnd值变成true。

接下来有两个函数，分别是查找字符串和查找前缀，它们的不同之处在于查找字符串不仅要保证searchPrefix(prefix) 返回的结点指针不为空，并且还要保证最后一个结点的isEnd属性为True;

而匹配前缀的算法只需要searchPrefix(prefix)返回的结点指针不为空；

```cpp
class Trie {
private:
    vector<Trie*> children;
    bool isEnd;

    Trie* searchPrefix(string prefix) {
        Trie* node = this;
        for (char ch : prefix) {
            ch -= 'a';
            if (node->children[ch] == nullptr) {
                return nullptr;
            }
            node = node->children[ch];
        }
        return node;
    }

public:
    Trie() : children(26), isEnd(false) {}

    void insert(string word) {
        Trie* node = this;
        for (char ch : word) {
            ch -= 'a';
            if (node->children[ch] == nullptr) {
                node->children[ch] = new Trie();
            }
            node = node->children[ch];
        }
        node->isEnd = true;
    }

    bool search(string word) {
        Trie* node = this->searchPrefix(word);
        return node != nullptr && node->isEnd;
    }

    bool startsWith(string prefix) {
        return this->searchPrefix(prefix) != nullptr;
    }
};

```

